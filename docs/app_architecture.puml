@startuml
package "metrics" {
    class "Graph" {
        + type: GraphType
        + title: str
        + precision: int
        + series: List[Serie]
        + xaxis?: Optional[str]
        + yaxis?: Optional[str]
        + categories: Optional[List[str]]
    }

    class "GraphType" {
        + EMPTY
        + LINE
        + COLUMN
    }

    class "Serie" {
        + title: str
        + data: List[Number]
    }

    "GraphType" - "Graph" : < uses
    "Graph" -- "Serie" : > contains
}

package "ai" {
    abstract class "Experiment" {
        ~ _beta: float
        ~ _learning_rate: float
        ~ _metrics: dict
        ~ _rng_wts: np.random.Generator
        + layers: List[Layer]
        + __init__(wt_init_seed: int, beta: float, learning_rate: float)
        ~ _hook_pre_train_step()
        ~ _hook_post_train_step()
        + build_small_three_layer_network(n_input_pyr_nrns: int, n_hidden_pyr_nrns: int, n_output_pyr_nrns: int)
        + train(n_steps: int, *args, **kwargs)
        ~ {abstract} _train_1_step(*args, **kwargs)
        + {abstract} extract_metrics(): List[Graph]
        + {abstract} run(*args, **kwargs)
    }

    class "NudgeExperiment" implements "Experiment" {
        ~ _nudge1: float
        ~ _nudge2: float
        + __init__(wt_init_seed: int, beta: float, learning_rate: float, nudge1: float, nudge2: float)
        - __do_ff_sweep()
        - __do_fb_sweep()
        - __train_1_step_rule_16b_and_rule_13(use_nudge: bool = False, use_rule_ip: bool = False)
        - __nudge_output_layer()
        ~ _hook_post_train_step()
        ~ _train_1_step(nudge_predicate: bool)
        + extract_metrics(): List[Graph]
        + run(self_prediction_steps: int, training_steps: int, after_training_steps: int)
    }

    class "XorExperiment" implements "Experiment" {
        - _X: np.ndarray
        - _Y: np.ndarray

        - _current_index: Optional[int]
        - _current_X: Optional[np.ndarray]
        - _current_Y: Optional[int]

        + __init__(wt_init_seed: int, label_init_seed: int, beta: float, learning_rate: float)
        - __do_ff_sweep()
        - __do_fb_sweep()
        - __gather_layer_metrics(key_post: str, key_wts: str, layer: Layer)
        - __nudge_output_layer()
        ~ _hook_pre_train_step()
        ~ _hook_post_train_step()
        ~ _train_1_step(nudge_predicate: bool)
        + extract_metrics(): List[Graph]
        + run(self_prediction_steps: int, training_steps: int, after_training_steps: int)
    }

    class "Layer" {
        + id_num: int
        + pyrs: List[Pyr]
        + inhibs: List[Inhib]
        + update_pyrs_basal_and_soma_ff(prev: Layer)
        + update_pyrs_apical_soma_fb(prev: Layer)
        + adjust_wts_lat_pi()
        + adjust_wts_pp_ff(prev: Layer)
        + apply_inputs_to_test_self_predictive_convergence(inputs: np.ndarray)
        + pyr_soma_acts(): List[float]
        + pyr_basal_hat_acts(): List[float]
        + pyr_soma_mps(): List[float]
        + pyr_basal_mps(): List[float]
    }

    class "Pyr" {
        + apical_mp: float
        + soma_act: float
        + W_PP_ff: List[float]
    }

    class "Inhib" {
        + soma_act: float
    }

    class "Main" << "entry point" >> {
        + main()
    }

    "Experiment" -> "Layer" : > contains
    "Layer" --> "Pyr" : > contains
    "Layer" --> "Inhib" : > contains
    "Main" --> "Experiment" : > uses
}

class "App" << Flask App >> {
    + list_experiments()
    + get_experiment_form()
    + get_experiment_data()
}

"App" --> "ai.Main" : > uses
"metrics.Graph" <- "ai.Main" : < returns
@enduml